import { Box, Typography } from "@mui/material";
import { useSnackbar } from "notistack";
import React, { FC, useEffect, useState } from "react";
import { Link, Prompt } from "react-router-dom";
import { useHistory } from "react-router-dom";
import { useAsync } from "react-use";

import { useAsyncWithThrow } from "../hooks/useAsyncWithThrow";

import { entitiesPath, entityEntriesPath, topPath } from "Routes";
import { aironeApiClientV2 } from "apiclient/AironeApiClientV2";
import { EntityUpdate, Webhook } from "apiclient/autogenerated";
import { AironeBreadcrumbs } from "components/common/AironeBreadcrumbs";
import { Loading } from "components/common/Loading";
import { PageHeader } from "components/common/PageHeader";
import { SubmitButton } from "components/common/SubmitButton";
import { EntityForm } from "components/entity/EntityForm";
import { useTypedParams } from "hooks/useTypedParams";

export const EditEntityPage: FC = () => {
  const { entityId } = useTypedParams<{ entityId: number }>();
  const history = useHistory();
  const { enqueueSnackbar } = useSnackbar();

  const [entityInfo, _setEntityInfo] = useState<EntityUpdate>({
    id: 0,
    name: "",
    note: "",
    isToplevel: false,
    webhooks: [],
    attrs: [],
  });
  const [submittable, setSubmittable] = useState<boolean>(false);
  const [submitted, setSubmitted] = useState<boolean>(false);
  const [edited, setEdited] = useState<boolean>(false);

  const entity = useAsyncWithThrow(async () => {
    if (entityId !== undefined) {
      return await aironeApiClientV2.getEntity(entityId);
    } else {
      return undefined;
    }
  }, []);

  const referralEntities = useAsync(async () => {
    const entities = await aironeApiClientV2.getEntities();
    return entities.results;
  });

  const setEntityInfo = (entityUpdate: EntityUpdate) => {
    setEdited(true);
    _setEntityInfo(entityUpdate);
  };

  const handleCancel = () => {
    if (entityId !== undefined) {
      history.replace(entityEntriesPath(entityId));
    } else {
      history.replace(entitiesPath());
    }
  };

  const handleSubmit = async () => {
    if (entityInfo.name == null) {
      throw new Error("entity name is not set");
    }

    const createMode = entityId === undefined;
    // Adjusted attributes for the API
    const attrs =
      entityInfo.attrs
        ?.filter((attr) => !(attr.id == null && attr.isDeleted))
        .map((attr, index) => {
          return {
            id: attr.id,
            name: attr.name,
            type: attr.type,
            index: index,
            isMandatory: attr.isMandatory,
            isDeleteInChain: attr.isDeleteInChain,
            isSummarized: attr.isSummarized,
            referral: attr.referral,
            isDeleted: attr.isDeleted,
          };
        }) ?? [];
    const webhooks =
      entityInfo.webhooks?.map(
        (webhook): Webhook => ({
          id: webhook.id ?? 0,
          url: webhook.url,
          label: webhook.label,
          isEnabled: webhook.isEnabled,
          isVerified: false,
          headers: webhook.headers,
          isDeleted: webhook.isDeleted,
        })
      ) ?? [];

    try {
      if (createMode) {
        await aironeApiClientV2.createEntity(
          entityInfo.name,
          entityInfo.note ?? "",
          entityInfo.isToplevel ?? false,
          // @ts-ignore
          attrs,
          webhooks
        );
        setSubmitted(true);
      } else {
        await aironeApiClientV2.updateEntity(
          entityId,
          entityInfo.name,
          entityInfo.note ?? "",
          entityInfo.isToplevel ?? false,
          attrs,
          webhooks
        );
        setSubmitted(true);
      }
    } catch (e) {
      if (e instanceof Response) {
        if (!e.ok) {
          const text = await e.text();
          enqueueSnackbar(text, { variant: "error" });
        }
      } else {
        throw e;
      }
    }
  };

  useEffect(() => {
    if (!entity.loading && entity.value !== undefined) {
      _setEntityInfo({
        ...entity.value,
        attrs:
          entity.value.attrs.map((attr) => ({
            ...attr,
            referral: attr.referral?.map((r) => r.id),
          })) ?? [],
      });
    }
  }, [entity.loading, entity.value]);

  // NOTE: This should be fixed in near future.
  // This unpeaceful impelmentation guarantees moving page after changing state "submitted"
  // by handleSubmit() processing to prevent showing wrong Prompt message.
  useEffect(() => {
    if (submitted) {
      history.replace(entityEntriesPath(entityId));
    }
  }, [submitted]);

  if (entity.loading || referralEntities.loading) {
    return <Loading />;
  }

  return (
    <Box>
      <AironeBreadcrumbs>
        <Typography component={Link} to={topPath()}>
          Top
        </Typography>
        <Typography component={Link} to={entitiesPath()}>
          エンティティ一覧
        </Typography>
        {entityId && (
          <Typography component={Link} to={entityEntriesPath(entityId)}>
            {entity?.value?.name ?? ""}
          </Typography>
        )}
        <Typography color="textPrimary">
          {entityId ? "エンティティ編集" : "新規エンティティの作成"}
        </Typography>
      </AironeBreadcrumbs>

      <PageHeader
        title={
          entity?.value != null ? entity.value.name : "新規エンティティの作成"
        }
        description={entity?.value && "エンティテイティ詳細 / 編集"}
      >
        <SubmitButton
          name="保存"
          disabled={!submittable}
          handleSubmit={handleSubmit}
          handleCancel={handleCancel}
        />
      </PageHeader>

      <EntityForm
        entityInfo={entityInfo}
        setEntityInfo={setEntityInfo}
        referralEntities={referralEntities.value}
        setSubmittable={setSubmittable}
      />
      <Prompt
        when={edited && !submitted}
        message="編集した内容は失われてしまいますが、このページを離れてもよろしいですか？"
      />
    </Box>
  );
};
